<div id="subaccountsEditor" ref:root>
	{#if busy}
		<div class="editorShield"></div>
	{/if}
	{#if $prefsLoaded}
		{#each Object.entries($subaccounts) as [owner, owned] (owner)}
			<SubaccountOwner {owner} {owned} on:add="edit('add', this)"
				on:remove="edit('remove', event)" on:changeOwner="edit('changeOwner', this)"/>
		{:else}
			<div id="subaccountsEditorExplainer">{$l10n("subaccountsEditorExplain")}</div>
		{/each}
		<div class="newOwner">
			{#if !showNewOwnerForm}
				<button type="button"
					on:click="set({showNewOwnerForm: true, newOwner: '', firstSubaccount: ''})">
					{$l10n("subaccountsEditorAddMainAccount")}
				</button>
			{:else}
				<form class="subaccountOwner newOwnerForm" on:submit="edit('newOwner')">
					<div class="editorLine ownerLine">
						<span class="accountName">
							<input bind:value="newOwner" required autofocus
								placeholder="{$l10n('subaccountsEditorOwnerPlaceholder')}">
						</span>
						<button type="button" tabindex="-1" class="cancelOwner"
							on:click="set({showNewOwnerForm: false})">
							{$l10n("subaccountsEditorCancelOwner")}
						</button>
					</div>
					<div class="editorLine firstSubaccount">
						<input bind:value="firstSubaccount" required
							placeholder="{$l10n('subaccountsEditorAddPlaceholder')}">
						<button type="submit">{$l10n("subaccountsAddConfirm")}</button>
					</div>
				</form>
			{/if}
		</div>
	{/if}
</div>
{#if warnings.length}
	<div class="subaccountsMessage warning">
		{#each warnings as {msg, parts}}
			<p>{$l10n("subaccountsWarning" + msg, parts)}</p>
		{/each}
	</div>
{/if}
{#if error}
	<div class="subaccountsMessage error">{$l10n("subaccountsError" + error.msg, error.parts)}</div>
{/if}
<script>
import SubaccountOwner from "./SubaccountOwner.html";
import lookUpDeviant from "../../report/lookUpDeviant.module.js";
export default {
	components: { SubaccountOwner },
	data() { return {
		warnings: [],
	}; },
	methods: {
		async edit(action, details) {
			if (this.get().busy) { return; }
			this.set({warnings: [], error: null});

			var ui = this, {store} = this, {subaccounts} = store.get();
			try {
				await ({
					async add(ownerComponent) {
						var {owner, newSubaccount} = ownerComponent.get();
						await addSubaccount(owner, newSubaccount);
						ownerComponent.set({showAddSubaccount: false});
					},
					async newOwner() {
						var {name, isOwner, ownedBy} = await nameCheck(ui.get().newOwner);
						if (ownedBy) {
							throw {msg: "OwnerIsOwned", parts: [name, ownedBy]};
						}
						if (isOwner) {
							ui.warn({msg: "OwnerAlreadyAdded", parts: [name]});
						}
						await addSubaccount(name, ui.get().firstSubaccount);
						ui.set({showNewOwnerForm: false});
					},
					remove({owner, removing}) {
						subaccounts[owner].splice(subaccounts[owner].indexOf(removing), 1);
						if (subaccounts[owner].length == 0) {
							delete subaccounts[owner];
						}
						store.set({subaccounts});
					},
					changeOwner(ownerComponent) {
						var {owner, newOwner} = ownerComponent.get();
						var newSubaccounts = {};
						for (let [entryOwner, owned] of Object.entries(subaccounts)) {
							if (entryOwner == owner) {
								owned[ owned.indexOf(newOwner) ] = owner;
								newSubaccounts[newOwner] = owned;
							} else {
								newSubaccounts[entryOwner] = owned;
							}
						}
						subaccounts = newSubaccounts;
						store.set({subaccounts});
					},
				})[action](details);
			} catch (error) {
				this.set({error});
			} finally {
				this.set({busy: false});
			}

			async function addSubaccount(owner, owned) {
				var {name, ownedBy, isOwner} = await nameCheck(owned);
				if (ownedBy) {
					throw {msg: "AlreadyOwned", parts: [ownedBy]};
				}
				if (!(owner in subaccounts)) {
					subaccounts[owner] = [];
				}
				subaccounts[owner].push(name);
				if (isOwner) {
					for (let subaccount of subaccounts[name]) {
						subaccounts[owner].push(subaccount);
					}
					delete subaccounts[name];
				}
				store.set({subaccounts});
			}
			function nameCheck(input) {
				var name = input.toLowerCase();
				for (let owner in subaccounts) {
					if (owner.toLowerCase() == name) {
						return {name: owner, isOwner: true};
					}
					for (let subaccount of subaccounts[owner]) {
						if (subaccount.toLowerCase() == name) {
							return {name: subaccount, ownedBy: owner};
						}
					}
				}
				ui.set({busy: true});
				return lookUpDeviant(name).then((results) => {
					if (results.name) {
						return {name: results.name};
					} else {
						ui.warn( {msg: "CantVerifyCasing", parts: [input]} );
						return { name: input };
					}
				}, (err) => {
					throw {msg: err, parts: [input]};
				});
			}
		},
		warn(warning) {
			var {warnings} = this.get();
			warnings.push(warning);
			this.set({warnings});
		},
	},
	oncreate() {
		this.refs.root.addEventListener("submit", (event) => {
			event.preventDefault();
		});
	},
};
</script>